/**
 * This class parser the file set in construct method.
 *
 * @author Gustavo Marques ( @GUTODISSE ) 
 * @version 05_01_2019
 */
package minipascal.syntatic_analyser;

import minipascal.syntatic_analyser.scanner;
import minipascal.syntatic_analyser.Token;


public class Parser
{
    private Token currentToken;
    private scanner current_scanner;
    
    /**
     * Method to handle all error and print more familiar errors
     *
     * @param  token_expected  
     * @return  void
     */
    
    private void handle_error(int token_expected)
    {
        String msg_error;
        System.out.println("[ERROR]");
        
        switch(token_expected)
        {
        
            case 1000:
                msg_error = new String("EXPECTED: LITERAL");
            break;
            case 1001:
                msg_error = new String("EXPECTED: TIPO");
            break;
            case 1002:
                msg_error = new String("EXPECTED: FATOR");
            break;
            case 1003:
                msg_error = new String("EXPECTED: COMANDO");
            break;
            default:
                msg_error = new String("EXPECTED: "+currentToken.spellings[token_expected]);
            break;
        } 
        System.out.println(msg_error);
        System.out.println("FOUND: "+currentToken.spellings[currentToken.kind] );
        current_scanner.errorHandler(true);
                
        System.exit(0);
        
    }
     
    private void acceptIt() throws Exception 
    {
        currentToken = current_scanner.scan();
        //currentToken.print();
    }

    private void accept (byte expectedKind) throws Exception
    {
        if(currentToken.kind == expectedKind)
            acceptIt();
        else
        {
            handle_error(expectedKind);
        }
    }
    
    private void parserIdentifier() throws Exception
    {
        if(currentToken.kind == Token.IDENTIFIER)
        {
            acceptIt();
        }
        else
        {
            handle_error(Token.IDENTIFIER);
        }
    }
    
    private void parseLiteral() throws Exception
    {
        switch(currentToken.kind)
        {
            case Token.INTLITERAL: case Token.FLOATLIT: case Token.TRUE:
            case Token.FALSE:
                     acceptIt();
            break;
            default:
                handle_error(1000);
            break;
        }    
    
    }
    
    private void parserTipo() throws Exception
    {
        switch(currentToken.kind)
        {
            case Token.ARRAY:
                accept(Token.ARRAY);
                accept(Token.R_SQUARE);
                parseLiteral();
                accept(Token.DOT);
                accept(Token.DOT);
                parseLiteral();
                accept(Token.L_SQUARE);
                accept(Token.OF);
                parserTipo();
            break;
            case Token.INTEGER: case Token.REAL: case Token.BOOLEAN:
                 acceptIt();
            break;
            default:
                handle_error(1001);
            break;
        }
    
    }
    
    // <declaração> ::= var <id> ( , <id> )* : <tipo>
    private void parseDeclaracao () throws Exception
    {
        accept(Token.VAR);
        parserIdentifier();
        while(currentToken.kind != Token.COLON)
        {
            accept(Token.COMMA);
            parserIdentifier();
        }
        accept(Token.COLON);
        parserTipo();
    }
    
    // <variável> ::= <id> ( [ <expressão> ] )*
    private void parserVariavel () throws Exception
    {
        parserIdentifier();
        
        while(currentToken.kind == Token.R_SQUARE)
        {
            accept(Token.R_SQUARE);
            parserExpressao();
            accept(Token.L_SQUARE);
        }
    }
    
    /*
        <fator> ::= 
                    <variável> 
                    | <literal> 
                    | ( <expressão> )
    */
    private void parserFator () throws Exception
    {
        switch(currentToken.kind)
        {
            case Token.IDENTIFIER:
                parserIdentifier();
            break;
            
            case Token.INTLITERAL: case Token.FLOATLIT: case Token.TRUE:
            case Token.FALSE:
                 parseLiteral();   
            break;
            
            case Token.R_PAREN:
                accept(Token.R_PAREN);
                parserExpressao();
                accept(Token.L_PAREN);
            break;
            default:
                handle_error(1002);
            break;    
        }
        
    
    }
   
    
    //<termo> ::= <fator>( (<op-mul> <fator>)* | <vazio> )
    private void parserTermo () throws Exception
    {
        parserFator();
        while(currentToken.kind == Token.OP_MUL)
        {
            accept(Token.OP_MUL);
            parserFator();
        };
    
    }
    
    //<expressão-simples> ::= <termo> (( <op-ad><termo> )* | <vazio ) 
    private void parserExpressaoSimples () throws Exception
    {
        parserTermo();
        while(currentToken.kind == Token.OP_AD)
        {
            accept(Token.OP_AD);
            parserTermo();
        };
    }
    
    // <expressão> ::= <expressão-simples> (  <op-rel> <expressão-simples> | <vazio> )
    private void parserExpressao () throws Exception
    {
        parserExpressaoSimples();
        while(currentToken.kind == Token.OP_REL)
        {
            accept(Token.OP_REL);
            parserExpressaoSimples();
        };
    }
    
    /*
        <comando> ::= 
        <variável> := <expressão>
                    | if <expressão> then <comando> ( else <comando> | <vazio> )
                    | while <expressão> do <comando>
                    | begin (<comando> ;)* end

    */
    private void parseComando () throws Exception
    {
        switch(currentToken.kind)
        {
            case Token.IDENTIFIER:
                parserVariavel();
                accept(Token.IS);
                parserExpressao();
            break;
            
            case Token.IF:
                accept(Token.IF);
                parserExpressao();
                accept(Token.THEN);
                parseComando ();
                
                if( currentToken.kind == Token.ELSE)
                {
                    accept(Token.ELSE);
                    parseComando ();
                }
            break;
            
            case Token.WHILE:
                accept(Token.WHILE);
                parserExpressao();
                accept(Token.DO);
                parseComando ();
            break;
            
            case Token.BEGIN:
                accept(Token.BEGIN);
                while(currentToken.kind != Token.END)
                {
                    parseComando();
                    accept(Token.SEMICOLON);
                }
                accept(Token.END);
            break;
            default:
                handle_error(1003);
            break;
        }
    
    }
    
    // <corpo> ::= (<declaração> ;)*  begin  ( <comando> ; )* end
    private void parseCorpo () throws Exception
    {
        // (<declaração> ;)*
        while(currentToken.kind == Token.VAR)
        {
            parseDeclaracao();
            accept(Token.SEMICOLON);
        }
        
        accept(Token.BEGIN);
        
        while(currentToken.kind != Token.END)
        {
            parseComando();
            accept(Token.SEMICOLON);
        }
               
        accept(Token.END);
    }
    
    
    // <programa> ::= program <id> ; <corpo> .
    private void parseProgram () throws Exception
    {
        accept(Token.PROGRAM);
        
        parserIdentifier();
        
        accept(Token.SEMICOLON);
        
        parseCorpo();
        
        accept(Token.DOT);
        accept(Token.EOT);
    }


    /**
    * Constructor for objects of class Parser
    */
    public Parser() throws Exception 
    {
        current_scanner = new scanner("/home/lampiao/Projects/MiniPascal_Compiler/Programs/2.mp");
        
        currentToken = current_scanner.scan();
        //currentToken.print();
        parseProgram();
        
    }
}
